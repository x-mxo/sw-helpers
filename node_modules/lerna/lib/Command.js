"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.builder = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.commandNameFromClassName = commandNameFromClassName;

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _dedent = require("dedent");

var _dedent2 = _interopRequireDefault(_dedent);

var _ChildProcessUtilities = require("./ChildProcessUtilities");

var _ChildProcessUtilities2 = _interopRequireDefault(_ChildProcessUtilities);

var _FileSystemUtilities = require("./FileSystemUtilities");

var _FileSystemUtilities2 = _interopRequireDefault(_FileSystemUtilities);

var _GitUtilities = require("./GitUtilities");

var _GitUtilities2 = _interopRequireDefault(_GitUtilities);

var _ExitHandler = require("./ExitHandler");

var _ExitHandler2 = _interopRequireDefault(_ExitHandler);

var _progressBar = require("./progressBar");

var _progressBar2 = _interopRequireDefault(_progressBar);

var _Repository = require("./Repository");

var _Repository2 = _interopRequireDefault(_Repository);

var _PackageUtilities = require("./PackageUtilities");

var _PackageUtilities2 = _interopRequireDefault(_PackageUtilities);

var _logger = require("./logger");

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_CONCURRENCY = 4;

var builder = exports.builder = {
  "loglevel": {
    default: "info",
    describe: "What level of logs to report.",
    type: "string"
  },
  "concurrency": {
    describe: "How many threads to use if lerna parallelises the tasks.",
    type: "number",
    requiresArg: true,
    default: DEFAULT_CONCURRENCY
  },
  "scope": {
    describe: _dedent2.default`
      Restricts the scope to package names matching the given glob.
      (Only for 'run', 'exec', 'clean', 'ls', and 'bootstrap' commands)
    `,
    type: "string",
    requiresArg: true
  },
  "ignore": {
    describe: _dedent2.default`
      Ignore packages with names matching the given glob.
      (Only for 'run', 'exec', 'clean', 'ls', and 'bootstrap' commands)
    `,
    type: "string",
    requiresArg: true
  },
  "include-filtered-dependencies": {
    describe: _dedent2.default`
      Include all transitive dependencies when running a command, regardless of --scope or --ignore.
    `
  },
  "registry": {
    describe: "Use the specified registry for all npm client operations.",
    type: "string",
    requiresArg: true
  },
  "sort": {
    describe: "Sort packages topologically (all dependencies before dependents)",
    type: "boolean",
    default: true
  }
};

var Command = function () {
  function Command(input, flags, cwd) {
    _classCallCheck(this, Command);

    this.input = input;
    this.flags = flags;

    this.lernaVersion = require("../package.json").version;
    this.logger = _logger2.default;
    this.logger.setLogLevel(flags.loglevel);
    this.progressBar = _progressBar2.default;
    this.repository = new _Repository2.default(cwd);
  }

  _createClass(Command, [{
    key: "run",
    value: function run() {
      this.logger.info("Lerna v" + this.lernaVersion);

      if (this.repository.isIndependent()) {
        this.logger.info("Independent Versioning Mode");
      }

      this.runValidations();
      this.runPreparations();
      this.runCommand();
    }
  }, {
    key: "runValidations",
    value: function runValidations() {
      if (!_GitUtilities2.default.isInitialized(this.repository.rootPath)) {
        this.logger.warn("This is not a git repository, did you already run `git init` or `lerna init`?");
        this._complete(null, 1);
        return;
      }

      if (!this.repository.packageJson) {
        this.logger.warn("`package.json` does not exist, have you run `lerna init`?");
        this._complete(null, 1);
        return;
      }

      if (!this.repository.initVersion) {
        this.logger.warn("`lerna.json` does not exist, have you run `lerna init`?");
        this._complete(null, 1);
        return;
      }

      if (this.options.independent && !this.repository.isIndependent()) {
        this.logger.warn("You ran lerna with `--independent` or `-i`, but the repository is not set to independent mode. " + "To use independent mode you need to set your `lerna.json` \"version\" to \"independent\". " + "Then you won't need to pass the `--independent` or `-i` flags.");
        this._complete(null, 1);
        return;
      }

      if (process.env.NODE_ENV !== "lerna-test" && !this.repository.isCompatibleLerna(this.lernaVersion)) {
        this.logger.warn(`Lerna major version mismatch: The current version of lerna is ${this.lernaVersion}, ` + `but the Lerna version in \`lerna.json\` is ${this.repository.initVersion}. ` + `You can either run \`lerna init\` again or install \`lerna@${this.repository.initVersion}\`.`);
        this._complete(null, 1);
        return;
      }

      /* eslint-disable max-len */
      // TODO: remove these warnings eventually
      if (_FileSystemUtilities2.default.existsSync(this.repository.versionLocation)) {
        this.logger.warn("You have a `VERSION` file in your repository, this is leftover from a previous version. Please run `lerna init` to update.");
        this._complete(null, 1);
        return;
      }

      if (process.env.NPM_DIST_TAG !== undefined) {
        this.logger.warn("`NPM_DIST_TAG=[tagname] lerna publish` is deprecated, please use `lerna publish --tag [tagname]` instead.");
        this._complete(null, 1);
        return;
      }

      if (process.env.FORCE_VERSION !== undefined) {
        this.logger.warn("`FORCE_VERSION=[package/*] lerna updated/publish` is deprecated, please use `lerna updated/publish --force-publish [package/*]` instead.");
        this._complete(null, 1);
        return;
      }

      if (this.options.onlyExplicitUpdates) {
        this.logger.warn("`--only-explicit-updates` has been removed. This flag was only ever added for Babel and we never should have exposed it to everyone.");
        this._complete(null, 1);
        return;
      }
      /* eslint-enable max-len */
    }
  }, {
    key: "runPreparations",
    value: function runPreparations() {
      var _options = this.options,
          scope = _options.scope,
          ignore = _options.ignore,
          registry = _options.registry;


      if (scope) {
        this.logger.info(`Scoping to packages that match '${scope}'`);
      }

      if (ignore) {
        this.logger.info(`Ignoring packages that match '${ignore}'`);
      }

      if (registry) {
        this.npmRegistry = registry;
      }

      try {
        this.repository.buildPackageGraph();
        this.packages = this.repository.packages;
        this.packageGraph = this.repository.packageGraph;
        this.filteredPackages = _PackageUtilities2.default.filterPackages(this.packages, { scope, ignore });

        if (this.options.includeFilteredDependencies) {
          this.filteredPackages = _PackageUtilities2.default.addDependencies(this.filteredPackages, this.packageGraph);
        }
      } catch (err) {
        this.logger.error("Errored while collecting packages and package graph", err);
        this._complete(null, 1);
        throw err;
      }
    }
  }, {
    key: "runCommand",
    value: function runCommand(callback) {
      var _this = this;

      this._attempt("initialize", function () {
        _this._attempt("execute", function () {
          _this._complete(null, 0, callback);
        }, callback);
      }, callback);
    }
  }, {
    key: "_attempt",
    value: function _attempt(method, next, callback) {
      var _this2 = this;

      var methodName = `${this.constructor.name}.${method}`;

      try {
        this.logger.verbose(`Attempting running ${methodName}`);

        this[method](function (err, completed) {
          if (err) {
            _this2.logger.error(`Errored while running ${methodName}`, err);
            _this2._complete(err, 1, callback);
          } else if (!completed) {
            _this2.logger.verbose(`Exited early while running ${methodName}`);
            _this2._complete(null, 1, callback);
          } else {
            _this2.logger.verbose(`Successfully ran ${methodName}`);
            next();
          }
        });
      } catch (err) {
        this.logger.error(`Errored while running ${methodName}`, err);
        this._complete(err, 1, callback);
      }
    }
  }, {
    key: "_complete",
    value: function _complete(err, code, callback) {
      if (code !== 0) {
        var exitHandler = new _ExitHandler2.default(this.repository.rootPath);
        exitHandler.writeLogs(this.logger);
      }

      var finish = function finish() {
        if (callback) {
          callback(err, code);
        }

        if (process.env.NODE_ENV !== "lerna-test") {
          // TODO: don't call process.exit()
          // eslint-disable-next-line no-process-exit
          process.exit(code);
        }
      };

      var childProcessCount = _ChildProcessUtilities2.default.getChildProcessCount();
      if (childProcessCount > 0) {
        this.logger.info(`Waiting for ${childProcessCount} child ` + `process${childProcessCount === 1 ? "" : "es"} to exit. ` + "CTRL-C to exit immediately.");
        _ChildProcessUtilities2.default.onAllExited(finish);
      } else {
        finish();
      }
    }
  }, {
    key: "_legacyOptions",
    value: function _legacyOptions() {
      var _this3 = this;

      return ["bootstrap", "publish"].reduce(function (opts, command) {
        if (_this3.name === command && _this3.repository.lernaJson[`${command}Config`]) {
          _this3.logger.warn(`\`${command}Config.ignore\` is deprecated.  Use \`commands.${command}.ignore\`.`);
          opts.ignore = _this3.repository.lernaJson[`${command}Config`].ignore;
        }
        return opts;
      }, {});
    }
  }, {
    key: "initialize",
    value: function initialize() {
      throw new Error("command.initialize() needs to be implemented.");
    }
  }, {
    key: "execute",
    value: function execute() {
      throw new Error("command.execute() needs to be implemented.");
    }
  }, {
    key: "concurrency",
    get: function get() {
      if (!this._concurrency) {
        var concurrency = this.options.concurrency;

        this._concurrency = Math.max(1, +concurrency || DEFAULT_CONCURRENCY);
      }

      return this._concurrency;
    }
  }, {
    key: "toposort",
    get: function get() {
      if (!this._toposort) {
        var sort = this.options.sort;
        // If the option isn't present then the default is to sort.

        this._toposort = sort == null || sort;
      }

      return this._toposort;
    }
  }, {
    key: "name",
    get: function get() {
      // For a class named "FooCommand" this returns "foo".
      return commandNameFromClassName(this.className);
    }
  }, {
    key: "className",
    get: function get() {
      return this.constructor.name;
    }
  }, {
    key: "execOpts",
    get: function get() {
      if (!this._execOpts) {
        this._execOpts = {
          cwd: this.repository.rootPath
        };
      }

      return this._execOpts;
    }

    // Override this to inherit config from another command.
    // For example `updated` inherits config from `publish`.

  }, {
    key: "otherCommandConfigs",
    get: function get() {
      return [];
    }
  }, {
    key: "options",
    get: function get() {
      if (!this._options) {
        // Command config object is either "commands" or "command".
        var _repository$lernaJson = this.repository.lernaJson,
            commands = _repository$lernaJson.commands,
            command = _repository$lernaJson.command;

        // The current command always overrides otherCommandConfigs

        var lernaCommandOverrides = [this.name].concat(_toConsumableArray(this.otherCommandConfigs)).map(function (name) {
          return (commands || command || {})[name];
        });

        this._options = _lodash2.default.defaults.apply(_lodash2.default, [{},
        // CLI flags, which if defined overrule subsequent values
        this.flags].concat(_toConsumableArray(lernaCommandOverrides), [
        // Global options from `lerna.json`
        this.repository.lernaJson,
        // Deprecated legacy options in `lerna.json`
        this._legacyOptions()]));
      }

      return this._options;
    }
  }]);

  return Command;
}();

exports.default = Command;
function commandNameFromClassName(className) {
  return className.replace(/Command$/, "").toLowerCase();
}