{"version":3,"sources":["browser/sw-utils.js"],"names":["e","t","n","r","s","o","u","a","require","i","f","Error","code","l","exports","call","length","1","module","_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","SWUtils","this","_testCounter","_testTime","Date","getTime","value","registration","desiredState","Promise","resolve","reject","installing","serviceWorker","stateChangeListener","evt","state","removeEventListener","addEventListener","_this","existingIframe","document","querySelector","newIframe","createElement","classList","add","src","body","appendChild","navigator","getRegistrations","then","registrations","all","map","unregister","window","caches","keys","cacheNames","cacheName","delete","swUrl","_this2","iframe","getIframe","options","scope","contentWindow","location","pathname","register","_onStateChangePromise","catch","err","_this3","activateSW","iframeSW","controller","once","cache","has","hasCache","open","openedCache","cachedRequests","cachedRequest","match","response","request","cacheRequestResponsePairs","output","forEach","cacheRequestResponsePair","url","unregisterAllRegistrations","clearAllCaches","iframeList","querySelectorAll","parentElement","removeChild","goog","swUtils"],"mappings":"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","file":"sw-utils.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n/**\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/* eslint-env browser */\n\n/**\n * <p>SWUtils can be used in a <strong>webpage only</strong>.</p>\n *\n * <p>This is helpful for managing service worker registrations and\n * cache creation / clean up between unit tests.</p>\n *\n * @example\n * <script src=\"/node_modules/sw-testing-helper/browser/sw-utils.js\"></script>\n *\n * <script>\n * \tconsole.log(window.goog.swUtils);\n * </script>\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar SWUtils = function () {\n  /**\n   * SWUtils constructor should never be called directly.\n   */\n  function SWUtils() {\n    _classCallCheck(this, SWUtils);\n\n    // The test counter ensures a unique scope between each test.\n    // testTime is used to ensure a unique scope between runs of\n    // the test suite - useful if manual testing parts of the\n    // suite in different tabs at the same time.\n    this._testCounter = 0;\n    this._testTime = new Date().getTime();\n  }\n\n  /**\n   * Helper method to determine when a specific state is achieved within\n   * a service worker (i.e. it becomes installed or activated).\n   *\n   * @private\n   *\n   * @param  {ServiceWorkerRegistration} registration registration to watch\n   *   for state changes\n   * @param  {String} desiredState Name of the desired state to wait for\n   * @return {Promise}        Resolves when the desired state is reached\n   */\n\n\n  _createClass(SWUtils, [{\n    key: '_onStateChangePromise',\n    value: function _onStateChangePromise(registration, desiredState) {\n      return new Promise(function (resolve, reject) {\n        if (registration.installing === null) {\n          throw new Error('Service worker is not installing. Did you call ' + 'cleanState() to unregister this service?');\n        }\n\n        var serviceWorker = registration.installing;\n\n        // We unregister all service workers after each test - this should\n        // always trigger an install state change\n        var stateChangeListener = function stateChangeListener(evt) {\n          if (evt.target.state === desiredState) {\n            serviceWorker.removeEventListener('statechange', stateChangeListener);\n            resolve();\n            return;\n          }\n\n          if (evt.target.state === 'redundant') {\n            serviceWorker.removeEventListener('statechange', stateChangeListener);\n\n            // Must call reject rather than throw error here due to this\n            // being inside the scope of the callback function stateChangeListener\n            reject(new Error('Installing servier worker became redundant'));\n            return;\n          }\n        };\n\n        serviceWorker.addEventListener('statechange', stateChangeListener);\n      });\n    }\n\n    /**\n     * <p>When a service worker is installed / activated using SWUtils,\n     * it'll be registered with a unqiue scope and an iframe will be\n     * created matching that scope (allowing it to be controlled by that\n     * service worker only).</p>\n     *\n     * <p>This method will get you the current iframe (if in the middle of a test)\n     * or create a new iframe.</p>\n     *\n     * @return {Promise.<HTMLElement>} Resolves to the current iframe being\n     * used for tests.\n     */\n\n  }, {\n    key: 'getIframe',\n    value: function getIframe() {\n      var _this = this;\n\n      return new Promise(function (resolve) {\n        var existingIframe = document.querySelector('.js-test-iframe');\n        if (existingIframe) {\n          return resolve(existingIframe);\n        }\n\n        // This will be used as a unique service worker scope\n        _this._testCounter++;\n\n        var newIframe = document.createElement('iframe');\n        newIframe.classList.add('js-test-iframe');\n        newIframe.addEventListener('load', function () {\n          resolve(newIframe);\n        });\n        newIframe.src = '/test/iframe/' + _this._testTime + _this._testCounter;\n        document.body.appendChild(newIframe);\n      });\n    }\n\n    /**\n     * Loop through all registrations for the current origin and unregister them.\n     *\n     * @return {Promise} Resolves once all promises are unregistered\n     */\n\n  }, {\n    key: 'unregisterAllRegistrations',\n    value: function unregisterAllRegistrations() {\n      return navigator.serviceWorker.getRegistrations().then(function (registrations) {\n        return Promise.all(registrations.map(function (registration) {\n          return registration.unregister();\n        }));\n      });\n    }\n\n    /**\n     * Loop over all caches for the current origin and delete them.\n     *\n     * @return {Promise} Resolves once all caches are deleted\n     */\n\n  }, {\n    key: 'clearAllCaches',\n    value: function clearAllCaches() {\n      return window.caches.keys().then(function (cacheNames) {\n        return Promise.all(cacheNames.map(function (cacheName) {\n          return window.caches.delete(cacheName);\n        }));\n      });\n    }\n\n    /**\n     * <p>Register a service worker to a unique scope and\n     * create an iframe it can control, wait until the service worker's\n     * install step has completed.</p>\n     *\n     * <p>Useful for testing events that occur in the install event (i.e.\n     * pre-caching of assets).</p>\n     *\n     * @param  {String} swUrl The url to a service worker file to register\n     * @return {Promise.<HTMLElement>}       Resolves once the service worker is\n     * installed and returns the iframe it controls.\n     */\n\n  }, {\n    key: 'installSW',\n    value: function installSW(swUrl) {\n      var _this2 = this;\n\n      return new Promise(function (resolve, reject) {\n        var iframe = void 0;\n        _this2.getIframe().then(function (newIframe) {\n          var options = null;\n          if (newIframe) {\n            iframe = newIframe;\n            options = { scope: newIframe.contentWindow.location.pathname };\n          }\n\n          return navigator.serviceWorker.register(swUrl, options);\n        }).then(function (registration) {\n          return _this2._onStateChangePromise(registration, 'installed');\n        }).then(function () {\n          return resolve(iframe);\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n\n    /**\n     * <p>Register a service worker with a unique scope and\n     * create an iframe that can be controlled by that service worker, then\n     * wait until the service worker's activate step has completed.</p>\n     *\n     * <p>Useful for testing fetch events that can't occur until after the\n     * service worker has activated.</p>\n     *\n     * @param  {String} swUrl The url to a service worker file to register\n     * @return {Promise.<HTMLElement>}       Resolves once the service worker is\n     * activated and returns the iframe it controls.\n     */\n\n  }, {\n    key: 'activateSW',\n    value: function activateSW(swUrl) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        var iframe = void 0;\n        _this3.getIframe().then(function (newIframe) {\n          var options = null;\n          if (newIframe) {\n            options = { scope: newIframe.contentWindow.location.pathname };\n            iframe = newIframe;\n          }\n          return navigator.serviceWorker.register(swUrl, options);\n        }).then(function (registration) {\n          return _this3._onStateChangePromise(registration, 'activated');\n        }).then(function () {\n          return resolve(iframe);\n        }).catch(function (err) {\n          return reject(err);\n        });\n      });\n    }\n\n    /**\n     * <p>Register a service worker with a unique scope and\n     * create an iframe that can be controlled by that service worker, then\n     * wait until the service worker takes control.</p>\n     *\n     * <p>Useful for testing behavior that assumes the page is already controlled\n     * by a service worker.</p>\n     *\n     * @param  {String} swUrl The url to a service worker file to register\n     * @return {Promise.<HTMLElement>} Resolves with the iframe once the service\n     * worker has taken control.\n     */\n\n  }, {\n    key: 'controlledBySW',\n    value: function controlledBySW(swUrl) {\n      return this.activateSW(swUrl).then(function (iframe) {\n        return new Promise(function (resolve) {\n          var iframeSW = iframe.contentWindow.navigator.serviceWorker;\n          if (iframeSW.controller) {\n            resolve(iframe);\n          } else {\n            iframeSW.addEventListener('controllerchange', function () {\n              return resolve(iframe);\n            }, { once: true });\n          }\n        });\n      });\n    }\n\n    /**\n     * <p>Helper method that checks a cache with a specific name exists before\n     * retrieving all the cached responses inside of it.</p>\n     *\n     * <p>This is limited to text responses at the moment.</p>\n     *\n     * <p><strong>NOTE: </strong>This will reject if the cache doesn't exist.</p>\n     *\n     * @param  {String} cacheName The name of the cache to get the contents from.\n     * @return {Promise.<Object>}           Resolves to an object where the keys\n     * are URLs for the cache responses and the value is the text from the\n     * response. The promise rejects if the cache doesn't exist.\n     */\n\n  }, {\n    key: 'getAllCachedAssets',\n    value: function getAllCachedAssets(cacheName) {\n      var cache = null;\n      return window.caches.has(cacheName).then(function (hasCache) {\n        if (!hasCache) {\n          throw new Error('Cache doesn\\'t exist.');\n        }\n\n        return window.caches.open(cacheName);\n      }).then(function (openedCache) {\n        cache = openedCache;\n        return cache.keys();\n      }).then(function (cachedRequests) {\n        return Promise.all(cachedRequests.map(function (cachedRequest) {\n          return cache.match(cachedRequest).then(function (response) {\n            return {\n              request: cachedRequest,\n              response: response\n            };\n          });\n        }));\n      }).then(function (cacheRequestResponsePairs) {\n        // This method extracts the response streams and pairs\n        // them with a url.\n        var output = {};\n        cacheRequestResponsePairs.forEach(function (cacheRequestResponsePair) {\n          output[cacheRequestResponsePair.request.url] = cacheRequestResponsePair.response;\n        });\n\n        return output;\n      });\n    }\n\n    /**\n     * Helper to unregister all service workers and clear all caches.\n     *\n     * @return {Promise} Resolves once service workers are unregistered and caches\n     * are deleted.\n     */\n\n  }, {\n    key: 'cleanState',\n    value: function cleanState() {\n      return Promise.all([this.unregisterAllRegistrations(), this.clearAllCaches()]).then(function () {\n        var iframeList = document.querySelectorAll('.js-test-iframe');\n        for (var i = 0; i < iframeList.length; i++) {\n          iframeList[i].parentElement.removeChild(iframeList[i]);\n        }\n      });\n    }\n  }]);\n\n  return SWUtils;\n}();\n\nwindow.goog = window.goog || {};\nwindow.goog.swUtils = window.goog.swUtils || new SWUtils();\n\n},{}]},{},[1]);\n"]}