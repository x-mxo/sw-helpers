---
layout: jsdoc
title: "Source: sw-precaching/src/lib/models/precache-entries/base-precache-entry.js"
jsdocNav: 
  - Modules:
    - <a href="module-sw-background-sync-queue.html#main">sw-background-sync-queue</a>
    - <a href="module-sw-broadcast-cache-update.html#main">sw-broadcast-cache-update</a>
    - <a href="module-sw-build.html#main">sw-build</a>
    - <a href="module-sw-cache-expiration.html#main">sw-cache-expiration</a>
    - <a href="module-sw-cacheable-response.html#main">sw-cacheable-response</a>
    - <a href="module-sw-lib.html#main">sw-lib</a>
    - <a href="module-sw-offline-google-analytics.html#main">sw-offline-google-analytics</a>
    - <a href="module-sw-precaching.html#main">sw-precaching</a>
    - <a href="module-sw-routing.html#main">sw-routing</a>
    - <a href="module-sw-runtime-caching.html#main">sw-runtime-caching</a>
---





    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import {cacheBustParamName} from '../../constants';

/**
 * This class is extended by a number of classes that take different inputs
 * and generates the required fields for a BaseCacheEntry.
 *
 * @private
 * @memberof module:sw-precaching
 */
class BaseCacheEntry {
  /**
   * This constructor expects an object and a number or required fields.
   * You shouldn't need to use this constructor directly.
   *
   * @param {Object} input
   * @param {String} input.entryID
   * @param {String} input.revision
   * @param {Request} input.request
   * @param {boolean} input.cacheBust
   */
  constructor({entryID, revision, request, cacheBust}) {
    this.entryID = entryID;
    this.revision = revision;
    this.request = request;
    this.cacheBust = cacheBust;
  }

  /**
   * This method is required since any revisioned request needs to cache bust.
   * To ensure this is consistent, CacheManagers will make a network request
   * using this specially formatted request.
   *
   * When caching the response, it will be cached against the origin `request`,
   * removing lookup for the cachebusted URL.
   *
   * @return {Request} Returns a cache busted request if needed, otherwise
   * a normal request with credentials set to 'same-origin' and redirect set to
   * follow.
   */
  getNetworkRequest() {
    if (this.cacheBust !== true) {
      // For the RequestCacheEntry we should return it to ensure headers are
      // kept in tact and part of the request.
      return this.request;
    }

    let url = this.request.url;
    const requestOptions = {};

    if (this.cacheBust === true) {
      if ('cache' in Request.prototype) {
        // Make use of the Request cache mode where we can.
        // Reload skips the HTTP cache for outgoing requests and updates
        // the cache with the returned reponse.
        requestOptions.cache = 'reload';
      } else {
        const parsedURL = new URL(url, location);
        parsedURL.search += (parsedURL.search ? '&amp;' : '') +
          encodeURIComponent(cacheBustParamName) + '=' +
          encodeURIComponent(this.revision);
        url = parsedURL.toString();
      }
    }

    return new Request(url, requestOptions);
  }
}

export default BaseCacheEntry;
</code></pre>
        </article>
    </section>




